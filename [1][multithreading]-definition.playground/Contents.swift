import UIKit
import XCPlayground

XCPlaygroundPage.currentPage.needsIndefiniteExecution = true
XCPlaygroundPage.currentPage.finishExecution()
/*:
 ###### 一些定义
 1. 同步与异步
 
 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
 
 换句话说，就是由*调用者*主动等待这个*调用*的结果。
 
 而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。
 
 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js
 
 举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。
 
 2. 阻塞与非阻塞
 
 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
 
 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
 
 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
 
 还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。
 
 3. 并发和并行的区别：
 
 所有的并发处理都有排队等候，唤醒和执行这三个步骤，所以并发是宏观的观念，在微观上他们都是序列被处理的，只不过资源不会在某一个上被阻塞（一般是通过时间片轮转），所以在宏观上多个几乎同时到达的请求同时在被处理。如果是同一时刻到达的请求也会根据优先级的不同，先后进入队列排队等候执行。
 
 并发与并行是两个既相似但是却不相同的概念：
 
 * 并发性：又称共行性，是指处理多个同时性活动的能力，。
 
 * 并行：指同时处理两个并发事件，具有并发的含义。并发不一定并行，也可以说并发事件之间不一定要同一时刻发生。
 
 并发的实质是一个物理CPU（也可以是多个物理CPU）在若干个程序之间多路复用，并发性是对有限物理资源强制行使 多用户共享以提高效率。
 
 并行指两个或两个以上事件或活动在同一时刻发生，在多道程序环境下，并行使多个程序同一时刻可在不同CPU上同时执行。
 
 并发是在同一个cpu上同时（不是真正的同时，而是看来是同时，因为CPU要在多个程序之间切换）运行多个程序。
 
 并行是每一个CPU运行一个程序。
 
 打个比方：并发就像一个人（CPU）喂两个小孩（程序）吃饭，表面上是两个小孩在吃饭，实际是一个人在喂。并行就是两个人喂两个小孩子吃饭。
 
 3. 进程与线程
 
 进程：
 
 * 进程是指在系统中正在运行的一个应用程序，比如同时打开微信和Xcode，系统会分别启动2个进程;
 * 每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内;
 
 线程：
 
 * 一个进程要想执行任务，必须得有线程（每一个进程至少要有一条线程)，是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位;
 * 一个进程（程序）的所有任务都在线程中执行;
 * 一个程序有且只有一个主线程，程序启动时创建（调用main来启动），主线程的生命周期是和应用程序绑定，程序退出时，主线程也停止;
 * 同一时间内，一个线程只能执行一个任务;
 * 线程自己不拥有系统资源，只拥有在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源;
 
 线程的几种状态：
 
 * 新建状态：新创建一个线程对象；
 * 就绪状态：线程对象创建之后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权；
 * 运行状态：就绪状态的线程获取了CPU，执行程序代码；
 * 阻塞状态：因某种原因放弃CPU使用权，暂停运行，知道线程进入就绪状态，才有机会转到运行状态；
 * 死亡状态：线程执行完了或者因异常退出了run方法，线程生命周期结束；
 ![image](thread-lifecycle.png)
 
 进程和线程比较：
 
 * 线程是CPU调度（执行任务）的最小单位，是程序执行的最小单元;
 * 进程是CPU分配资源和调度的单位;
 * 一个进程可以有多个线程，但至少要有一个线程，而一个线程只能属于一个进程;
 * 同一个进程内的线程共享进程的所有资源;
 
 4. iOS中多线程的实现方案：
 
 * pthread ：一套通用的多线程API，适用于Unix、Linux、Windows等系统，跨平台、可移植，使用难度大，c语言，线程生命周期由程序员管理
 * NSTread：oc语言，面向对象，简单易用，可直接操作线程对象 ，线程生命周期由程序员管理
 * GCD:（常用）替代NSTread等线程技术，充分利用设备的多核，线程生命周期自动管理，c语言
 * NSOperation:（常用）底层是GCD，比GCD多了一些更简单实用的功能，使用更加面向对象，线程生命周期自动管理
 */


/*:
 ##### 参考文章：
 * [https://www.zhihu.com/question/19732473](https://www.zhihu.com/question/19732473)
 * [https://www.cnblogs.com/xiaowangzi1987/p/6706416.html](https://www.cnblogs.com/xiaowangzi1987/p/6706416.html)
 * [https://www.cnblogs.com/hs-funky/p/6512515.html](https://www.cnblogs.com/hs-funky/p/6512515.html)
 */
