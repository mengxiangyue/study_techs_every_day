import UIKit

/*:
 死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
 
 活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。
 
 饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。
 
 优先级反转：优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。
 
 高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。
 
 过多的线程，反而会降低性能，每次线程切换的时候，CPU需要切换上下文，这个也耗费时间。
 */

//print("1")
//DispatchQueue.main.sync {
//    print("2")
//}
//print("3")

//let queue = DispatchQueue(label: "com.yuange")
//queue.sync {
//    print("1")
//    queue.sync {
//        print("2")
//    }
//    print("3")
//}

let queue = DispatchQueue(label: "com.yuange", attributes: .concurrent)
queue.sync {
    print("1 \(Thread.current)")
    queue.sync {
        Thread.sleep(forTimeInterval: 1)
        print("2 \(Thread.current)")
    }
    print("3 \(Thread.current)")
}

